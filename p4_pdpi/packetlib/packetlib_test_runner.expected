================================================================================
Parsing test: Ethernet packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x002e  # This means size(payload) = 0x2e bytes = 46 bytes.
    # payload
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x002e"
  }
}
payload: "0x00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff00112233445566778899aabbccdd"

================================================================================
Parsing test: Ethernet packet (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0001  # This means size(payload) = 1 byte.
    # payload
    payload: 0x0102  # 2 bytes, but ether_type says 1 byte & minimum size is 46.
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0001"
  }
}
payload: "0x0102"
reasons_invalid: "headers[0].ethertype: value 0x0001 is <= 1500 and should thus match payload size, but payload size is 2 bytes"
reasons_invalid: "headers[0].: expected at least 46 bytes of Ethernet payload, but got only 2"

================================================================================
Parsing test: Ethernet packet (unsupported EtherType)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0842  # Wake-on-LAN
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0842"
  }
}
reason_unsupported: "ethernet_header.ethertype 0x0842: unsupported"
reasons_invalid: "headers[0].: expected at least 46 bytes of Ethernet payload, but got only 0"

================================================================================
Parsing test: IPv4 packet (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x5
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x6fc6
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0x1234
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    # other headers:
    payload: 0x1234
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x6fc6"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0x1234"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "0x1234"
reason_unsupported: "ipv4_header.protocol 0x05: unsupported"
reasons_invalid: "headers[0].: expected at least 46 bytes of Ethernet payload, but got only 22"
reasons_invalid: "headers[1].total_length: Must be 0x0016, but was 0x6fc6 instead."
reasons_invalid: "headers[1].checksum: Must be 0x78f5, but was 0x1234 instead."

================================================================================
Parsing test: IPv4 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x5
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x0034
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0xe887
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    # payload:
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0034"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "0x00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff"
reason_unsupported: "ipv4_header.protocol 0x05: unsupported"

================================================================================
Parsing test: IPv4 packet (checksum example)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # wikipedia.org/wiki/IPv4_header_checksum#Calculating_the_IPv4_header_checksum
    #
    # ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header and payload
    ipv4_header: 0x 4500 0073 0000 4000 4011 b861 c0a8 0001 c0a8 00c7
    payload: 0x 0035 e97c 005f 279f 1e4b 8180
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x0073"
    identification: "0x0000"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0x40"
    protocol: "0x11"
    checksum: "0xb861"
    ipv4_source: "192.168.0.1"
    ipv4_destination: "192.168.0.199"
  }
}
headers {
  udp_header {
    source_port: "0x0035"
    destination_port: "0xe97c"
    length: "0x005f"
    checksum: "0x279f"
  }
}
payload: "0x1e4b8180"
reasons_invalid: "headers[0].: expected at least 46 bytes of Ethernet payload, but got only 32"
reasons_invalid: "headers[1].total_length: Must be 0x0020, but was 0x0073 instead."
reasons_invalid: "headers[2].length: Must be 0x000c, but was 0x005f instead."
reasons_invalid: "headers[2].checksum: Must be 0xf399, but was 0x279f instead."

================================================================================
Parsing test: IPv4 packet with options (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x6  # 5 + 1 x 32-bit suffix
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x0038
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0xa31d
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    uninterpreted_suffix: 0x11223344
    # Payload
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0038"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xa31d"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
    uninterpreted_options: "0x11223344"
  }
}
payload: "0x00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff"
reason_unsupported: "ipv4_header.protocol 0x05: unsupported"

================================================================================
Parsing test: IPv4 packet with options (too short)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x6  # 5 + 1 x 32-bit suffix
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x0018
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0xd6a3
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    uninterpreted_suffix: 0x11  # Should be 32 bits, but is only 8 bits.
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0018"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xd6a3"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
    uninterpreted_options: "0x11"
  }
}
reason_unsupported: "ipv4_header.protocol 0x05: unsupported"
reasons_invalid: "headers[0].: expected at least 46 bytes of Ethernet payload, but got only 21"
reasons_invalid: "headers[1].uninterpreted_options: found 8 bits, but expected multiple of 32 bits"
reasons_invalid: "headers[1].ihl: Correct value undefined since uninterpreted_options is invalid."
reasons_invalid: "headers[1].total_length: Must be 0x0015, but was 0x0018 instead."

================================================================================
Parsing test: IPv6 packet (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xffeeddccbbaa
    ethernet_source: 0x554433221100
    ether_type: 0x86DD
    # IPv6 header:
    version: 0x4
    dscp: 0b011011
    ecn: 0b01
    flow_label: 0x12345
    payload_length: 0x0000
    next_header: 0x90  # some unassigned protocol
    hop_limit: 0xff
    ipv6_source: 0x00001111222233334444555566667777
    ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
    # other headers:
    payload: 0x12
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x4"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0x90"
    hop_limit: "0xff"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "0x12"
reason_unsupported: "ipv6_header.next_header 0x90: unsupported"
reasons_invalid: "headers[0].: expected at least 46 bytes of Ethernet payload, but got only 41"
reasons_invalid: "headers[1].version: Must be 0x6, but was 0x4 instead."
reasons_invalid: "headers[1].payload_length: Must be 0x0001, but was 0x0000 instead."

================================================================================
Parsing test: IPv6 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xffeeddccbbaa
    ethernet_source: 0x554433221100
    ether_type: 0x86DD
    # IPv6 header:
    version: 0x6
    dscp: 0b011011
    ecn: 0b01
    flow_label: 0x12345
    payload_length: 0x0020
    next_header: 0x90  # some unassigned protocol
    hop_limit: 0x03
    ipv6_source: 0x00001111222233334444555566667777
    ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
    # other headers:
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0020"
    next_header: "0x90"
    hop_limit: "0x03"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "0x00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff"
reason_unsupported: "ipv6_header.next_header 0x90: unsupported"

================================================================================
Parsing test: UDP packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.securitynik.com/2015/08/calculating-udp-checksum-with-taste-of.html
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header
    version: 0x4
    ihl: 0x5
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x002e
    identification: 0x0000
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x11  # UDP
    checksum: 0x28c5
    ipv4_source: 0xc0a8001f       # 192.168.0.31
    ipv4_destination: 0xc0a8001e  # 192.168.0.30
    # UDP header
    source_port: 0x0014       # 20
    destination_port: 0x000a  # 10
    length: 0x001a            # 26
    checksum: 0x7961
    # Payload
    payload: 0x4869                                             # "Hi" in ASCII
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff  # Padding
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x002e"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x11"
    checksum: "0x28c5"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x001a"
    checksum: "0x7961"
  }
}
payload: "0x486900112233445566778899aabbccddeeff"

================================================================================
Parsing test: TCP packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.erg.abdn.ac.uk/users/gorry/course/inet-pages/packet-decode3.html
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x 00 e0 f7 26 3f e9
    ethernet_source: 0x 08 00 20 86 35 4b
    ether_type: 0x0800
    # IPv4 header
    version: 0x4
    ihl: 0x5
    dscp: 0b000000
    ecn: 0b00
    total_length: 0x002e
    identification: 0x08b8
    flags: 0b010
    fragment_offset: 0b0000000000000
    ttl: 0xff
    protocol: 0x06  # TCP
    checksum: 0x9995
    ipv4_source: 0x8b85d96e       # 139.133.217.110
    ipv4_destination: 0x8b85e902  # 139.133.233.2
    # TCP header
    source_port: 0x9005          # 36869
    destination_port: 0x0017     # 23 (TELNET)
    sequence_number: 0x7214f114  # 1913975060
    acknowledgement_number: 0x00000000
    data_offset: 0x6  # 6 x 32 bits = 24 bytes
    reserved: 0b000
    flags: 0b 0 0 0 0 0 0 0 1 0  # SYN
    window_size: 0x2238          # 8760
    checksum: 0xa92c
    urgent_pointer: 0x0000
    options: 0x 0204 05b4
    # Payload
    payload: 0x 11 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "00:e0:f7:26:3f:e9"
    ethernet_source: "08:00:20:86:35:4b"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x002e"
    identification: "0x08b8"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xff"
    protocol: "0x06"
    checksum: "0x9995"
    ipv4_source: "139.133.217.110"
    ipv4_destination: "139.133.233.2"
  }
}
headers {
  tcp_header_prefix {
    source_port: "0x9005"
    destination_port: "0x0017"
  }
}
payload: "0x7214f1140000000060022238a92c0000020405b41122"
reason_unsupported: "TCP only partially supported -- parsing prefix of header containing ports only"

================================================================================
Parsing test: ARP Packet (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0x ff ff ff ff ff ff
    ethernet_source: 0x 00 11 22 33 44 55
    ether_type: 0x0806
    # ARP header
    hardware_type: 0x0001  # Ethernet
    protocol_type: 0x0800  # IPv4
    hardware_length: 0x06
    protocol_length: 0x04
    operation: 0x0001  # Request
    sender_hardware_address: 0x 00 11 22 33 44 55
    sender_protocol_address: 0x 0a 00 00 01
    target_hardware_address: 0x 00 00 00 00 00 00
    target_protocol_address: 0x 0a 00 00 02
    # Payload
    payload: 0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "00:11:22:33:44:55"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "00:11:22:33:44:55"
    sender_protocol_address: "10.0.0.1"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "10.0.0.2"
  }
}
payload: "0x000000000000000000000000000000000000"

================================================================================
Parsing test: ICMPv4 Packet (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.erg.abdn.ac.uk/users/gorry/course/inet-pages/packet-dec1.html
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x 08 00 20 86 35 4b
    ethernet_source: 0x 00 e0 f7 26 3f e9
    ether_type: 0x0800
    # IPv4 header
    version: 0x4
    ihl: 0x5
    dscp: 0b000000
    ecn: 0b00
    total_length: 0x0054
    identification: 0xaafb
    flags: 0b010  # website's 0x4 is from interpreting 4 bits.
    fragment_offset: 0b0000000000000
    ttl: 0xfc       # 252
    protocol: 0x01  # ICMP
    checksum: 0xfa30
    ipv4_source: 0x 8b 85 e9 02       # 139.133.233.2
    ipv4_destination: 0x 8b 85 d9 6e  # 139.133.233.110
    # ICMP header
    type: 0x00
    code: 0x00
    checksum: 0x45da
    rest_of_header: 0x 1e 60 00 00
    # payload
    payload: 0x 33 5e 3a b8 00 00 42 ac 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14
    payload: 0x 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29
    payload: 0x 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "08:00:20:86:35:4b"
    ethernet_source: "00:e0:f7:26:3f:e9"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x0054"
    identification: "0xaafb"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xfc"
    protocol: "0x01"
    checksum: "0xfa30"
    ipv4_source: "139.133.233.2"
    ipv4_destination: "139.133.217.110"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    checksum: "0x45da"
    rest_of_header: "0x1e600000"
  }
}
payload: "0x335e3ab8000042ac08090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637"

================================================================================
Parsing test: ICMPv6 Packet (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.cloudshark.org/captures/e98730aee1fb
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x c2 01 51 fa 00 00
    ethernet_source: 0x c2 00 51 fa 00 00
    ethertype: 0x86dd
    # IPv6 header:
    version: 0x6
    dscp: 0b000000
    ecn: 0b00
    flow_label: 0x00000
    payload_length: 0x003c
    next_header: 0x3a  # ICMP
    hop_limit: 0x40
    ipv6_source: 0x20010db8000000120000000000000001
    ipv6_destination: 0x20010db8000000120000000000000002
    # ICMP header:
    type: 0x80
    code: 0x00
    checksum: 0x863c
    rest_of_header: 0x 11 0d 00 00
    # payload
    payload: 0x 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14
    payload: 0x 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29
    payload: 0x 2a 2b 2c 2d 2e 2f 30 31 32 33
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x003c"
    next_header: "0x3a"
    hop_limit: "0x40"
    ipv6_source: "2001:db8:0:12::1"
    ipv6_destination: "2001:db8:0:12::2"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    checksum: "0x863c"
    rest_of_header: "0x110d0000"
  }
}
payload: "0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233"

================================================================================
Parsing test: VLAN Packet with ARP (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.cloudshark.org/captures/e7f1b8c0b434
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x ff ff ff ff ff ff
    ethernet_source: 0x 00 19 06 ea b8 c1
    ether_type: 0x8100
    # VLAN header
    priority_code_point: 0b000
    drop_eligibility_indicator: 0b0
    vlan_identifier: 0x07b
    ether_type: 0x0806
    # ARP header
    hardware_type: 0x0001  # Ethernet
    protocol_type: 0x0800  # IPv4
    hardware_length: 0x06
    protocol_length: 0x04
    operation: 0x0002  # Reply
    sender_hardware_address: 0x 00 19 06 ea b8 c1
    sender_protocol_address: 0x c0 a8 7b 01
    target_hardware_address: 0x ff ff ff ff ff ff
    target_protocol_address: 0x c0 a8 7b 01
    # Payload
    payload: 0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "00:19:06:ea:b8:c1"
    ethertype: "0x8100"
  }
}
headers {
  vlan_header {
    priority_code_point: "0x0"
    drop_eligible_indicator: "0x0"
    vlan_identifier: "0x07b"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0002"
    sender_hardware_address: "00:19:06:ea:b8:c1"
    sender_protocol_address: "192.168.123.1"
    target_hardware_address: "ff:ff:ff:ff:ff:ff"
    target_protocol_address: "192.168.123.1"
  }
}
payload: "0x000000000000000000000000000000000000"

================================================================================
Proto packet test: UDP header not preceded by other header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x000a"
    checksum: "0x35c5"
  }
}
payload: "0x4869"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].checksum: UDP header must be preceded by IP header for checksum to be defined; found no header instead

PadPacketToMinimumSize(packet) = false

UpdateComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].checksum: UDP header must be preceded by IP header for checksum to be defined; found no header instead

================================================================================
Proto packet test: UDP header not preceded by IP header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x000a"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x000a"
    checksum: "0x35c5"
  }
}
payload: "0x4869"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 10
- headers[1].checksum: UDP header must be preceded by IP header for checksum to be defined; found EthernetHeader at headers[0] instead
- headers[1]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

PadPacketToMinimumSize(packet) = true
new payload: "0x4869000000000000000000000000000000000000000000000000000000000000000000000000"

UpdateComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].ethertype: value 0x000a is <= 1500 and should thus match payload size, but payload size is 46 bytes
- headers[1].length: Must be 0x002e, but was 0x000a instead.
- headers[1].checksum: UDP header must be preceded by IP header for checksum to be defined; found EthernetHeader at headers[0] instead
- headers[1]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

================================================================================
Proto packet test: UDP header empty length and checksum
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x11"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
  }
}
payload: "0x4869"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 30
- headers[1].total_length: missing
- headers[1].checksum: missing
- headers[2].length: missing
- headers[2].checksum: missing

PadPacketToMinimumSize(packet) = true
new payload: "0x486900000000000000000000000000000000"

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x002e"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x11"
    checksum: "0x28c5"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x001a"
    checksum: "0x35a5"
  }
}
payload: "0x486900000000000000000000000000000000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: UDP header illegally succeeding IPv6 header whose next_header is not UDP
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x000a"
    next_header: "0x90"
    hop_limit: "0x03"
    ipv6_source: "0000:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
  }
}
payload: "0x4869"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[2].length: missing
- headers[2].checksum: missing
- headers[2]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

PadPacketToMinimumSize(packet) = false

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x000a"
    next_header: "0x90"
    hop_limit: "0x03"
    ipv6_source: "0000:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x000a"
    checksum: "0xb6d4"
  }
}
payload: "0x4869"

ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[2]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[2]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

================================================================================
Proto packet test: IPv4 without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    dscp: "0x1b"
    ecn: "0x1"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "0xabcd"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 22
- headers[1].version: missing
- headers[1].ihl: missing
- headers[1].total_length: missing
- headers[1].checksum: missing

PadPacketToMinimumSize(packet) = true
new payload: "0xabcd000000000000000000000000000000000000000000000000"

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x002e"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe88d"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "0xabcd000000000000000000000000000000000000000000000000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: Ipv4 empty ihl, invalid options
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0025"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
    uninterpreted_options: "0x12"
  }
}
payload: "0x00112233445566778899aabbccddeeff"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 37
- headers[1].ihl: missing
- headers[1].uninterpreted_options: found 8 bits, but expected multiple of 32 bits
- headers[1].checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: missing '0x'-prefix in hexadecimal string: ''

PadPacketToMinimumSize(packet) = true
new payload: "0x00112233445566778899aabbccddeeff000000000000000000"

UpdateComputedFields(packet) = INVALID_ARGUMENT: failed to compute packet.headers[1].ihl: uninterpreted_options field is invalid

Serialize(Packet) = INVALID_ARGUMENT: failed to compute packet.headers[1].ihl: uninterpreted_options field is invalid

================================================================================
Proto packet test: Ipv4 empty ihl, valid options
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    dscp: "0x011011"
    ecn: "0x01"
    total_length: "0x0034"
    identification: "0xa3cd"
    flags: "0x000"
    fragment_offset: "0x0000000000000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "0x0a000001"
    ipv4_destination: "0x14000003"
    uninterpreted_options: "0x12345678"
  }
}
payload: "0x00112233445566778899aabbccddeeff"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 40
- headers[1].ihl: missing
- headers[1].dscp: invalid format: illegal conversion from hex string '0x011011' to 6 bits; expected between 21 and 24 bits
- headers[1].ecn: invalid format: illegal conversion from hex string '0x01' to 2 bits; expected between 5 and 8 bits
- headers[1].flags: invalid format: illegal conversion from hex string '0x000' to 3 bits; expected between 9 and 12 bits
- headers[1].fragment_offset: invalid format: illegal conversion from hex string '0x0000000000000' to 13 bits; expected between 49 and 52 bits
- headers[1].ipv4_source: invalid format: Invalid IPv4 address: '0x0a000001'
- headers[1].ipv4_destination: invalid format: Invalid IPv4 address: '0x14000003'
- headers[1].total_length: Must be 0x0028, but was 0x0034 instead.
- headers[1].checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: missing '0x'-prefix in hexadecimal string: ''

PadPacketToMinimumSize(packet) = true
new payload: "0x00112233445566778899aabbccddeeff000000000000"

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x6"
    dscp: "0x011011"
    ecn: "0x01"
    total_length: "0x0034"
    identification: "0xa3cd"
    flags: "0x000"
    fragment_offset: "0x0000000000000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "0x0a000001"
    ipv4_destination: "0x14000003"
    uninterpreted_options: "0x12345678"
  }
}
payload: "0x00112233445566778899aabbccddeeff000000000000"

ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1].dscp: invalid format: illegal conversion from hex string '0x011011' to 6 bits; expected between 21 and 24 bits
- headers[1].ecn: invalid format: illegal conversion from hex string '0x01' to 2 bits; expected between 5 and 8 bits
- headers[1].flags: invalid format: illegal conversion from hex string '0x000' to 3 bits; expected between 9 and 12 bits
- headers[1].fragment_offset: invalid format: illegal conversion from hex string '0x0000000000000' to 13 bits; expected between 49 and 52 bits
- headers[1].ipv4_source: invalid format: Invalid IPv4 address: '0x0a000001'
- headers[1].ipv4_destination: invalid format: Invalid IPv4 address: '0x14000003'
- headers[1].total_length: Must be 0x002e, but was 0x0034 instead.
- headers[1].checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: illegal conversion from hex string '0x011011' to 6 bits; expected between 21 and 24 bits

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1].dscp: invalid format: illegal conversion from hex string '0x011011' to 6 bits; expected between 21 and 24 bits
- headers[1].ecn: invalid format: illegal conversion from hex string '0x01' to 2 bits; expected between 5 and 8 bits
- headers[1].flags: invalid format: illegal conversion from hex string '0x000' to 3 bits; expected between 9 and 12 bits
- headers[1].fragment_offset: invalid format: illegal conversion from hex string '0x0000000000000' to 13 bits; expected between 49 and 52 bits
- headers[1].ipv4_source: invalid format: Invalid IPv4 address: '0x0a000001'
- headers[1].ipv4_destination: invalid format: Invalid IPv4 address: '0x14000003'
- headers[1].total_length: Must be 0x002e, but was 0x0034 instead.
- headers[1].checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: illegal conversion from hex string '0x011011' to 6 bits; expected between 21 and 24 bits

================================================================================
Proto packet test: IPv4 with various invalid fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x3"
    ihl: "0x6k"
    dscp: "0x1b"
    ecn: "0x1"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    ipv4_source: "ffff:1::"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "0xabcd"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].ethernet_source: missing
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 22
- headers[1].ihl: invalid format: illegal conversion from hex string '0x6k' to 4 bits; expected between 5 and 8 bits
- headers[1].total_length: missing
- headers[1].checksum: missing
- headers[1].ipv4_source: invalid format: Invalid IPv4 address: 'ffff:1::'
- headers[1].version: Must be 0x4, but was 0x3 instead.

PadPacketToMinimumSize(packet) = true
new payload: "0xabcd000000000000000000000000000000000000000000000000"

UpdateComputedFields(packet) = INVALID_ARGUMENT: failed to compute packet.headers[1].checksum: illegal conversion from hex string '0x6k' to 4 bits; expected between 5 and 8 bits

Serialize(Packet) = INVALID_ARGUMENT: failed to compute packet.headers[1].checksum: illegal conversion from hex string '0x6k' to 4 bits; expected between 5 and 8 bits

================================================================================
Proto packet test: IPv6 without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    next_header: "0x05"
    hop_limit: "0x10"
    ipv6_source: "::"
    ipv6_destination: "f::f"
  }
}
payload: "0xabcd"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 42
- headers[1].version: missing
- headers[1].payload_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "0xabcd00000000"

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0006"
    next_header: "0x05"
    hop_limit: "0x10"
    ipv6_source: "::"
    ipv6_destination: "f::f"
  }
}
payload: "0xabcd00000000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: IPv6 with various invalid fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x4"
    dscp: "1b"
    ecn: "0b01"
    flow_label: "0x1234"
    payload_length: "0x0000"
    next_header: "0x050"
    hop_limit: "0x1"
    ipv6_source: "20.0.0.3"
    ipv6_destination: ":"
  }
}
payload: "0xabcd"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 42
- headers[1].dscp: invalid format: missing '0x'-prefix in hexadecimal string: '1b'
- headers[1].ecn: invalid format: missing '0x'-prefix in hexadecimal string: '0b01'
- headers[1].flow_label: invalid format: illegal conversion from hex string '0x1234' to 20 bits; expected between 13 and 16 bits
- headers[1].next_header: invalid format: illegal conversion from hex string '0x050' to 8 bits; expected between 9 and 12 bits
- headers[1].hop_limit: invalid format: illegal conversion from hex string '0x1' to 8 bits; expected between 1 and 4 bits
- headers[1].ipv6_source: invalid format: invalid IPv6 address: '20.0.0.3'
- headers[1].ipv6_destination: invalid format: invalid IPv6 address: ':'
- headers[1].version: Must be 0x6, but was 0x4 instead.
- headers[1].payload_length: Must be 0x0002, but was 0x0000 instead.

PadPacketToMinimumSize(packet) = true
new payload: "0xabcd00000000"

UpdateComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1].dscp: invalid format: missing '0x'-prefix in hexadecimal string: '1b'
- headers[1].ecn: invalid format: missing '0x'-prefix in hexadecimal string: '0b01'
- headers[1].flow_label: invalid format: illegal conversion from hex string '0x1234' to 20 bits; expected between 13 and 16 bits
- headers[1].next_header: invalid format: illegal conversion from hex string '0x050' to 8 bits; expected between 9 and 12 bits
- headers[1].hop_limit: invalid format: illegal conversion from hex string '0x1' to 8 bits; expected between 1 and 4 bits
- headers[1].ipv6_source: invalid format: invalid IPv6 address: '20.0.0.3'
- headers[1].ipv6_destination: invalid format: invalid IPv6 address: ':'
- headers[1].version: Must be 0x6, but was 0x4 instead.
- headers[1].payload_length: Must be 0x0006, but was 0x0000 instead.

================================================================================
Proto packet test: IPv6 packet with IPv4 ethertype
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0x05"
    hop_limit: "0x10"
    ipv6_source: "::"
    ipv6_destination: "f::f"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 40
- headers[1]: expected Ipv4Header (because the previous header demands it), got Ipv6Header

PadPacketToMinimumSize(packet) = true
new payload: "0x000000000000"

UpdateComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1].payload_length: Must be 0x0006, but was 0x0000 instead.
- headers[1]: expected Ipv4Header (because the previous header demands it), got Ipv6Header

================================================================================
Proto packet test: IPv6 packet without IPv6 header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
payload: "0xabcd"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 2
- headers[1]: header missing - expected Ipv6Header

PadPacketToMinimumSize(packet) = true
new payload: "0xabcd0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"

UpdateComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1]: header missing - expected Ipv6Header

================================================================================
Proto packet test: ARP packet without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 28
- headers[1].hardware_type: missing
- headers[1].protocol_type: missing
- headers[1].hardware_length: missing
- headers[1].protocol_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "0x000000000000000000000000000000000000"

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}
payload: "0x000000000000000000000000000000000000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: ARP packet with unsupported computed field values
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0002"
    protocol_type: "0x0801"
    hardware_length: "0x07"
    protocol_length: "0x05"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 28
- headers[1].hardware_type: Must be 0x0001, but was 0x0002 instead.
- headers[1].protocol_type: Must be 0x0800, but was 0x0801 instead.
- headers[1].hardware_length: Must be 0x06, but was 0x07 instead.
- headers[1].hardware_type: Must be 0x04, but was 0x05 instead.

PadPacketToMinimumSize(packet) = true
new payload: "0x000000000000000000000000000000000000"

UpdateComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1].hardware_type: Must be 0x0001, but was 0x0002 instead.
- headers[1].protocol_type: Must be 0x0800, but was 0x0801 instead.
- headers[1].hardware_length: Must be 0x06, but was 0x07 instead.
- headers[1].hardware_type: Must be 0x04, but was 0x05 instead.

================================================================================
Proto packet test: ICMPv4 packet without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "08:00:20:86:35:4b"
    ethernet_source: "00:e0:f7:26:3f:e9"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    dscp: "0x00"
    ecn: "0x0"
    identification: "0xaafb"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xfc"
    protocol: "0x01"
    ipv4_source: "139.133.233.2"
    ipv4_destination: "139.133.217.110"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    rest_of_header: "0x1e600000"
  }
}
payload: "0x335e3ab8000042ac08090a0b0c0d0e0f101112131415"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1].version: missing
- headers[1].ihl: missing
- headers[1].total_length: missing
- headers[1].checksum: missing
- headers[2].checksum: missing

PadPacketToMinimumSize(packet) = false

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "08:00:20:86:35:4b"
    ethernet_source: "00:e0:f7:26:3f:e9"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x0032"
    identification: "0xaafb"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xfc"
    protocol: "0x01"
    checksum: "0xfa52"
    ipv4_source: "139.133.233.2"
    ipv4_destination: "139.133.217.110"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    checksum: "0xce73"
    rest_of_header: "0x1e600000"
  }
}
payload: "0x335e3ab8000042ac08090a0b0c0d0e0f101112131415"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: ICMPv6 packet without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    next_header: "0x3a"
    hop_limit: "0x40"
    ipv6_source: "2001:db8:0:12::1"
    ipv6_destination: "2001:db8:0:12::2"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    rest_of_header: "0x110d0000"
  }
}
payload: "0x000102030405060708090a0b0c0d0e0f101112131415"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1].version: missing
- headers[1].payload_length: missing
- headers[2].checksum: missing

PadPacketToMinimumSize(packet) = false

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x001e"
    next_header: "0x3a"
    hop_limit: "0x40"
    ipv6_source: "2001:db8:0:12::1"
    ipv6_destination: "2001:db8:0:12::2"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    checksum: "0xa487"
    rest_of_header: "0x110d0000"
  }
}
payload: "0x000102030405060708090a0b0c0d0e0f101112131415"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: ICMP packet without a preceding IP header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    rest_of_header: "0x110d0000"
  }
}
payload: "0x000102030405060708090a0b0c0d0e0f101112131415"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 30
- headers[1].checksum: missing
- headers[1].checksum: ICMP header must be preceded by IP header for checksum to be defined; found EthernetHeader at headers[0] instead
- headers[1]: expected Ipv6Header (because the previous header demands it), got IcmpHeader

PadPacketToMinimumSize(packet) = true
new payload: "0x000102030405060708090a0b0c0d0e0f10111213141500000000000000000000000000000000"

UpdateComputedFields(packet) = INVALID_ARGUMENT: IcmpHeaderChecksum(packet, icmp_header_index = 1): expected packet.headers[udp_header_index - 1] to be an IP header, got EthernetHeader

Serialize(Packet) = INVALID_ARGUMENT: IcmpHeaderChecksum(packet, icmp_header_index = 1): expected packet.headers[udp_header_index - 1] to be an IP header, got EthernetHeader

================================================================================
Proto packet test: VLAN ARP packet
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x8100"
  }
}
headers {
  vlan_header {
    priority_code_point: "0x0"
    drop_eligible_indicator: "0x1"
    vlan_identifier: "0x123"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[0].: expected at least 46 bytes of Ethernet payload, but got only 32
- headers[2].hardware_type: missing
- headers[2].protocol_type: missing
- headers[2].hardware_length: missing
- headers[2].protocol_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "0x0000000000000000000000000000"

UpdateComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x8100"
  }
}
headers {
  vlan_header {
    priority_code_point: "0x0"
    drop_eligible_indicator: "0x1"
    vlan_identifier: "0x123"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}
payload: "0x0000000000000000000000000000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: Uninitialized (empty packet) - should be invalid
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- Packet is empty.

PadPacketToMinimumSize(packet) = false

UpdateComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- Packet is empty.

